#include <iostream>
#include <cstdlib>
#include <sstream>
#include <cstring>
#include <fstream>
#include <unordered_map>
#include <unordered_set>
#include <thread>
#include <mutex>
#include <vector>
#include <memory>
#include <unistd.h>
#include "Road.h"
#include "Global.h"
#include "Town.h"
#include "Lock.h"
#include "Agent.h"
#include <nlohmann/json.hpp>

using namespace std;
std::mutex mylock;

struct RNG
{
    int operator()(int n)
    {
        return std::rand() / (1.0 + RAND_MAX) * n;
    }
};

//Ricardo: Generate a specific number of agents and randomly initialize their starting location given all the available town cells)
unordered_map<int, std::shared_ptr<Agent>> generate_all_agents(int col_dim,  vector<int> &shuffled_grids, unordered_map<int, int> grid_to_town, int num_of_agents, unordered_map<int, Lock*> l)
{
    unordered_map<int, std::shared_ptr<Agent>> result;
    for (auto pair: grid_to_town)
    {
        if(l.find(pair.first-1) == l.end() && l.find(pair.first+1) == l.end() && l.find(pair.first+col_dim) == l.end() &&l.find(pair.first-col_dim) == l.end() )
        shuffled_grids.push_back(pair.first);
    }
    std::random_shuffle(shuffled_grids.begin(), shuffled_grids.end(), RNG());
    for (int i = 1; i <= num_of_agents; i++)
    {
        int start_x = shuffled_grids[i - 1] % col_dim;
        int start_y = shuffled_grids[i - 1] / col_dim;
        int town_id = grid_to_town[shuffled_grids[i - 1]];
        std::shared_ptr<Agent> a = std::make_shared<Agent>(i, town_id, make_pair(start_x, start_y));  // Agent *a = new Agent(i, town_id, make_pair(start_x, start_y));
        // cout << "create agent a with agent id " << a->get_agent_id() <<" town id " << town_id << " in position " << start_x<<" " <<start_y<< "with grid id " <<shuffled_grids[i - 1]<< endl; 
        a->add_past_path(make_pair(start_x, start_y));
        result.insert(make_pair(i, a));
        cout << "start loc. agent id = " << i << " with location x, y = " << start_x << "," << start_y << endl;
    }
    return result;
}

// Ricardo: Generate a specific number of random tasks for all agents( now assume the goals will not be repeated, each cell will only be the goal of one agent for one time)
unordered_map<int, deque<pair<int, int>>> generate_tasks(int col_dim, unordered_map<int, std::shared_ptr<Agent>> all_agent, vector<int> shuffled_grids, int num_of_tasks)
{
    unordered_map<int, deque<pair<int, int>>> result;
    int temp_count = 0;
    int total_count = all_agent.size();
    for (int i = 1; i <= total_count; i++)
    {
        deque<pair<int, int>> temp_deque;
        result.insert(make_pair(i, temp_deque));
    }
    int total_grids = shuffled_grids.size();
    int counter = 0;
    while ((total_count < total_grids) && (total_count < (all_agent.size() * num_of_tasks + all_agent.size())))
    {
        counter++;
        temp_count++;
        int start_x = shuffled_grids[total_count] % col_dim;
        int start_y = shuffled_grids[total_count] / col_dim;
        result[temp_count].push_back(make_pair(start_x, start_y));
        temp_count = temp_count % all_agent.size();
        total_count++;
        if (total_count >= total_grids) {
            total_count = 0;
        }
        if (counter >= all_agent.size() * num_of_tasks) {
            break;
        }
    }
    return result;
}

//Ricardo: Intialize all locks, and the map between town_id  and the vector of all locks in this town
unordered_map<int, Lock *> generate_all_locks(ifstream &lockfile, int col_dim, unordered_map<int, vector<Lock *>> &tl)
{
    unordered_map<int, Lock *> result;
    string line;
    while (getline(lockfile, line))
    {
        stringstream ss(line);
        int lock_id;
        int town_id;
        ss >> lock_id >> town_id;
        int y = lock_id / col_dim;
        int x = lock_id % col_dim;
        Lock *temp_lock = new Lock(lock_id, make_pair(x, y), town_id);
        tl[town_id].push_back(temp_lock);
        result.insert(make_pair(lock_id, temp_lock));
    }
    return result;
}

//Ricardo: Initialize all locks' reachability given the lock info file generated by SDM
unordered_map<int, unordered_set<int>> generate_lock_reachability(int col_dim, ifstream &lockfile, unordered_map<int, Lock *> &l)
{
    unordered_map<int, unordered_set<int>> result;
    string line;
    while (getline(lockfile, line))
    {
        int id, nothing;
        stringstream ss(line);
        ss >> id >> nothing;
        int new_id;
        unordered_set<int> emptyset;
        while (ss >> new_id)
        {
            emptyset.insert(new_id);
        }
        result.insert(make_pair(id, emptyset));
    }
    return result;
}

int pair_to_index(pair<int, int> pair, int num_col) {
    return pair.first + pair.second * num_col; 
}

int main(int argc, char *argv[])
{
    cout << "start global " << endl;
    // pre-preocess
    std::shared_ptr<Global> global = std::make_shared<Global>();  // Global *global = new Global();
    //generate towns and read town maps
    int town_number = 121;
    vector<thread> townThreads(town_number);
    unordered_map<int, std::shared_ptr<Town>> towns;
    for(int i=0;i<town_number;i++){
        towns[i] = std::make_shared<Town>(i, global);
        thread temp(&Town::run, towns[i]);
        townThreads[i] = move(temp);
    }
    //generate all agents
   
    

    ifstream lockfile;
    ifstream lockfile1;
    lockfile1.open("empty-128-128-9/locks.txt");
    lockfile.open("empty-128-128-9/locks.txt");
    unordered_map<int, vector<Lock*>> town_to_lock;
    unordered_map<int, Lock*> l = generate_all_locks(lockfile, global->get_col_dim(), town_to_lock);  // all locks
    lockfile.close();
    global->set_all_locks(l);
    vector<int> shuffled;
    unordered_map<int, std::shared_ptr<Agent>> a =  generate_all_agents(global->get_col_dim(),shuffled, global->get_gridid_to_townid(), 200, l); // agents
    cout << "THE NUMBER OF AVAILABLE GOALS is " << shuffled.size() << endl;
    global->set_all_agents(a);
    //set the agent list for town
    for(int i=0;i<town_number;i++){
        towns[i]->setAgentList(a);
        towns[i]->start_the_town();
    }


    unordered_map<int, deque<pair<int, int>>> t = generate_tasks(global->get_col_dim(), a, shuffled, 5);  // number of goals

    global->set_tasks(t);
    // for(auto& p:t){
    //     cout << "agent id " << p.first <<" goal is ";
    //     deque<pair<int,int>> d = p.second;
    //     while(!d.empty()){
    //         pair<int,int> front = d.front();
    //         d.pop_front();
    //         cout << "< " <<front.first<<" , " << front.second << " >, " ;
    //     }
    //     cout << endl;
    // }
    
    global->set_town_locks(town_to_lock);

    unordered_map<int, int> gtt = global->get_gridid_to_townid();  // grid id to town id

    global->set_gridid_to_townid(gtt);

    unordered_map<int, unordered_set<int>> lr = generate_lock_reachability(global->get_col_dim(), lockfile1, l);
    lockfile1.close();
    // cout << "size of lock reachability = " << lr.size() << endl;
    // for(auto pair:lr){
    //     cout << "For lock id " << pair.first << " the size of its reachability is " << pair.second.size() << endl;
    // }
    // for(int i = 0; i < 4; i++){
    //     unordered_set<int> u;
    //     lr[i] = u;
    // } 
    // lr[l[l1]->get_lock_id()].insert(l[l3]->get_lock_id());
    // lr[l[l2]->get_lock_id()].insert(l[l0]->get_lock_id());
    global->set_lock_reachability(lr);
    // DS: prepare all maps needed
    ifstream mapfile("empty-128-128-9/highways.txt");
   
    std::shared_ptr<Road> road = std::make_shared<Road>(mapfile);  //  Road *road = new Road(mapfile);
    road->set_global(global);

    //start here


    global->set_road(road);
    global->set_all_towns(towns);
    // start the process
    
    thread roadThread(&Road::run, road);
    thread globalThread(&Global::run, global);
    globalThread.join();
    for(int i=0;i<town_number;i++){
        townThreads[i].join();
    }
    roadThread.join();
    
    
    return 0;
}